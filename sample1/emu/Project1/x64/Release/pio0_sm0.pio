; automatically generated by picopio_emu

.program pio0_sm0
.side_set 3

.wrap_target	; line 001
	nop	side 0x01	; line 002
	nop	side 0x02	[1]	; line 003
	nop	side 0x04	[2]	; line 004
.wrap	; line 005

% c-sdk {
// see also (api):   https://raspberrypi.github.io/pico-sdk-doxygen/group__hardware__pio.html
// see also (pio.h): https://raspberrypi.github.io/pico-sdk-doxygen/rp2__common_2hardware__pio_2include_2hardware_2pio_8h_source.html
// see also (sm):    https://raspberrypi.github.io/pico-sdk-doxygen/group__sm__config.html

void pio0_sm0_config(
	PIO		pio,
	uint	sm,
	float	clkdiv
)
{
	int		i;
	uint	prog_addr;

	if (clkdiv < 1.0) {
		printf("asm_exec(): too small clkdiv\n");
		return;
	}

	// load program to PIO
	prog_addr			= pio_add_program(pio, &pio0_sm0_program);
	pio_sm_config	c	= pio0_sm0_program_get_default_config(prog_addr);	// addr
	sm_config_set_clkdiv(&c, clkdiv);	// pio_sm_config *c, float div

	// input
	if (-1 > 0) {
		for (i = 0; i < -1; i++) {
			pio_gpio_init(pio, -1 + i);	// PIO pio, uint pin
			pio_sm_set_consecutive_pindirs(pio, sm, -1 + i, 1, false);	// PIO pio, uint sm, uint pin_base, uint pin_count, bool is_out
		}
		sm_config_set_in_pins(&c, -1);	// pio_sm_config *c, uint in_base
	}

	// sideset
	if (3 > 0) {
		for (i = 0; i < 3; i++) {
			pio_gpio_init(pio, 0 + i);	// PIO pio, uint pin
			pio_sm_set_consecutive_pindirs(pio, sm, 0 + i, 1, true);	// PIO pio, uint sm, uint pin_base, uint pin_count, bool is_out
		}
		sm_config_set_sideset_pins(&c, 0);	// pio_sm_config *c, uint sideset_base
	}

	// output
	if (-1 > 0) {
		for (i = 0; i < -1; i++) {
			pio_gpio_init(pio, -1 + i);	// PIO pio, uint pin
			pio_sm_set_consecutive_pindirs(pio, sm, -1 + i, 1, true);	// PIO pio, uint sm, uint pin_base, uint pin_count, bool is_out
		}
		if (-1 <= 5)			sm_config_set_set_pins(&c, -1, -1);	// pio_sm_config *c, uint set_base, uint set_count
		else
			sm_config_set_set_pins(&c, -1, 5);	// pio_sm_config *c, uint set_base, uint set_count
		sm_config_set_out_pins(&c, -1, -1);	// pio_sm_config *c, uint out_base, uint out_count
	}

	// fifo, isr and osr
	sm_config_set_in_shift(&c, false, false, 32);		// pio_sm_config *c, bool shift_right, bool autopush, uint push_threshold
	sm_config_set_out_shift(&c, true, false, 32);		// pio_sm_config *c, bool shift_right, bool autopull, uint pull_threshold

	// "move status" instruction
	sm_config_set_mov_status(&c, STATUS_TX_LESSTHAN, 4);	// pio_sm_config *c, enum pio_mov_status_type status_sel, uint status_n

	pio_sm_clear_fifos(pio, sm);	// PIO pio, uint sm
	pio_sm_init(pio, sm, prog_addr, &c);	// PIO pio, uint sm, uint initial_pc, const pio_sm_config *config
}
%}
