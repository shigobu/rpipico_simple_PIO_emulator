; automatically generated by picopio_emu

.program pio0_sm1
.side_set 3 opt

.wrap_target	; line 001
	wait	0 pin 0x00	side 0x01	; line 002
	wait	1 pin 0x00	side 0x02	; line 003
	set	y 0x04	side 0x00	; line 004
loop_top:	; line 005
	pull	block	side 0x03	; line 006
	mov	x !osr	side 0x04	[1]	; line 007
	out	pins 0x01	side 0x00	; line 008
	in	x 0x20	; line 009
	push	block	side 0x05	; line 010
	jmp	y--	loop_top	side 0x00	; line 011
loop_end:	; line 012
	in	y 0x20	side 0x00	; line 013
	push	block	side 0x00	; line 014
	irq	wait 1	side 0x00	; line 015
	wait	0 pin 0x01	side 0x06	; line 016
	wait	1 pin 0x01	side 0x07	; line 017
.wrap	; line 018

% c-sdk {
// see also (api):   https://raspberrypi.github.io/pico-sdk-doxygen/group__hardware__pio.html
// see also (pio.h): https://raspberrypi.github.io/pico-sdk-doxygen/rp2__common_2hardware__pio_2include_2hardware_2pio_8h_source.html
// see also (sm):    https://raspberrypi.github.io/pico-sdk-doxygen/group__sm__config.html

void pio0_sm1_config(
	PIO		pio,
	uint	sm,
	float	clkdiv
)
{
	int		i;
	uint	prog_addr;

	if (clkdiv < 1.0) {
		printf("asm_exec(): too small clkdiv\n");
		return;
	}

	// load program to PIO
	prog_addr			= pio_add_program(pio, &pio0_sm1_program);
	pio_sm_config	c	= pio0_sm1_program_get_default_config(prog_addr);	// addr
	sm_config_set_clkdiv(&c, clkdiv);	// pio_sm_config *c, float div

	// input
	if (2 > 0) {
		for (i = 0; i < 2; i++) {
			pio_gpio_init(pio, 16 + i);	// PIO pio, uint pin
			pio_sm_set_consecutive_pindirs(pio, sm, 16 + i, 1, false);	// PIO pio, uint sm, uint pin_base, uint pin_count, bool is_out
		}
		sm_config_set_in_pins(&c, 16);	// pio_sm_config *c, uint in_base
	}

	// sideset
	if (3 > 0) {
		for (i = 0; i < 3; i++) {
			pio_gpio_init(pio, 8 + i);	// PIO pio, uint pin
			pio_sm_set_consecutive_pindirs(pio, sm, 8 + i, 1, true);	// PIO pio, uint sm, uint pin_base, uint pin_count, bool is_out
		}
		sm_config_set_sideset_pins(&c, 8);	// pio_sm_config *c, uint sideset_base
	}

	// output
	if (1 > 0) {
		for (i = 0; i < 1; i++) {
			pio_gpio_init(pio, 12 + i);	// PIO pio, uint pin
			pio_sm_set_consecutive_pindirs(pio, sm, 12 + i, 1, true);	// PIO pio, uint sm, uint pin_base, uint pin_count, bool is_out
		}
		if (1 <= 5)			sm_config_set_set_pins(&c, 12, 1);	// pio_sm_config *c, uint set_base, uint set_count
		else
			sm_config_set_set_pins(&c, 12, 5);	// pio_sm_config *c, uint set_base, uint set_count
		sm_config_set_out_pins(&c, 12, 1);	// pio_sm_config *c, uint out_base, uint out_count
	}

	// fifo, isr and osr
	sm_config_set_in_shift(&c, false, false, 32);		// pio_sm_config *c, bool shift_right, bool autopush, uint push_threshold
	sm_config_set_out_shift(&c, true, false, 32);		// pio_sm_config *c, bool shift_right, bool autopull, uint pull_threshold

	// "move status" instruction
	sm_config_set_mov_status(&c, STATUS_TX_LESSTHAN, 4);	// pio_sm_config *c, enum pio_mov_status_type status_sel, uint status_n

	pio_sm_clear_fifos(pio, sm);	// PIO pio, uint sm
	pio_sm_init(pio, sm, prog_addr, &c);	// PIO pio, uint sm, uint initial_pc, const pio_sm_config *config
}
%}
