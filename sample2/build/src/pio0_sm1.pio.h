// -------------------------------------------------- //
// This file is autogenerated by pioasm; do not edit! //
// -------------------------------------------------- //

#pragma once

#if !PICO_NO_HARDWARE
#include "hardware/pio.h"
#endif

// -------- //
// pio0_sm1 //
// -------- //

#define pio0_sm1_wrap_target 0
#define pio0_sm1_wrap 13

static const uint16_t pio0_sm1_program_instructions[] = {
            //     .wrap_target
    0x3220, //  0: wait   0 pin, 0        side 1     
    0x34a0, //  1: wait   1 pin, 0        side 2     
    0xf044, //  2: set    y, 4            side 0     
    0x96a0, //  3: pull   block           side 3     
    0xb92f, //  4: mov    x, !osr         side 4 [1] 
    0x7001, //  5: out    pins, 1         side 0     
    0x4020, //  6: in     x, 32                      
    0x9a20, //  7: push   block           side 5     
    0x1083, //  8: jmp    y--, 3          side 0     
    0x5040, //  9: in     y, 32           side 0     
    0x9020, // 10: push   block           side 0     
    0xd021, // 11: irq    wait 1          side 0     
    0x3c21, // 12: wait   0 pin, 1        side 6     
    0x3ea1, // 13: wait   1 pin, 1        side 7     
            //     .wrap
};

#if !PICO_NO_HARDWARE
static const struct pio_program pio0_sm1_program = {
    .instructions = pio0_sm1_program_instructions,
    .length = 14,
    .origin = -1,
};

static inline pio_sm_config pio0_sm1_program_get_default_config(uint offset) {
    pio_sm_config c = pio_get_default_sm_config();
    sm_config_set_wrap(&c, offset + pio0_sm1_wrap_target, offset + pio0_sm1_wrap);
    sm_config_set_sideset(&c, 4, true, false);
    return c;
}

// see also (api):   https://raspberrypi.github.io/pico-sdk-doxygen/group__hardware__pio.html
// see also (pio.h): https://raspberrypi.github.io/pico-sdk-doxygen/rp2__common_2hardware__pio_2include_2hardware_2pio_8h_source.html
// see also (sm):    https://raspberrypi.github.io/pico-sdk-doxygen/group__sm__config.html
void pio0_sm1_config(
	PIO		pio,
	uint	sm,
	float	clkdiv
)
{
	int		i;
	uint	prog_addr;
	if (clkdiv < 1.0) {
		printf("asm_exec(): too small clkdiv\n");
		return;
	}
	// load program to PIO
	prog_addr			= pio_add_program(pio, &pio0_sm1_program);
	pio_sm_config	c	= pio0_sm1_program_get_default_config(prog_addr);	// addr
	sm_config_set_clkdiv(&c, clkdiv);	// pio_sm_config *c, float div
	// input
	if (2 > 0) {
		for (i = 0; i < 2; i++) {
			pio_gpio_init(pio, 16 + i);	// PIO pio, uint pin
			pio_sm_set_consecutive_pindirs(pio, sm, 16 + i, 1, false);	// PIO pio, uint sm, uint pin_base, uint pin_count, bool is_out
		}
		sm_config_set_in_pins(&c, 16);	// pio_sm_config *c, uint in_base
	}
	// sideset
	if (3 > 0) {
		for (i = 0; i < 3; i++) {
			pio_gpio_init(pio, 8 + i);	// PIO pio, uint pin
			pio_sm_set_consecutive_pindirs(pio, sm, 8 + i, 1, true);	// PIO pio, uint sm, uint pin_base, uint pin_count, bool is_out
		}
		sm_config_set_sideset_pins(&c, 8);	// pio_sm_config *c, uint sideset_base
	}
	// output
	if (1 > 0) {
		for (i = 0; i < 1; i++) {
			pio_gpio_init(pio, 12 + i);	// PIO pio, uint pin
			pio_sm_set_consecutive_pindirs(pio, sm, 12 + i, 1, true);	// PIO pio, uint sm, uint pin_base, uint pin_count, bool is_out
		}
		if (1 <= 5)			sm_config_set_set_pins(&c, 12, 1);	// pio_sm_config *c, uint set_base, uint set_count
		else
			sm_config_set_set_pins(&c, 12, 5);	// pio_sm_config *c, uint set_base, uint set_count
		sm_config_set_out_pins(&c, 12, 1);	// pio_sm_config *c, uint out_base, uint out_count
	}
	// fifo, isr and osr
	sm_config_set_in_shift(&c, false, false, 32);		// pio_sm_config *c, bool shift_right, bool autopush, uint push_threshold
	sm_config_set_out_shift(&c, true, false, 32);		// pio_sm_config *c, bool shift_right, bool autopull, uint pull_threshold
	// "move status" instruction
	sm_config_set_mov_status(&c, STATUS_TX_LESSTHAN, 4);	// pio_sm_config *c, enum pio_mov_status_type status_sel, uint status_n
	pio_sm_clear_fifos(pio, sm);	// PIO pio, uint sm
	pio_sm_init(pio, sm, prog_addr, &c);	// PIO pio, uint sm, uint initial_pc, const pio_sm_config *config
}

#endif

