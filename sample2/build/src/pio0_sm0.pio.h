// -------------------------------------------------- //
// This file is autogenerated by pioasm; do not edit! //
// -------------------------------------------------- //

#pragma once

#if !PICO_NO_HARDWARE
#include "hardware/pio.h"
#endif

// -------- //
// pio0_sm0 //
// -------- //

#define pio0_sm0_wrap_target 0
#define pio0_sm0_wrap 2

static const uint16_t pio0_sm0_program_instructions[] = {
            //     .wrap_target
    0xa442, //  0: nop                    side 1     
    0xa942, //  1: nop                    side 2 [1] 
    0xb242, //  2: nop                    side 4 [2] 
            //     .wrap
};

#if !PICO_NO_HARDWARE
static const struct pio_program pio0_sm0_program = {
    .instructions = pio0_sm0_program_instructions,
    .length = 3,
    .origin = -1,
};

static inline pio_sm_config pio0_sm0_program_get_default_config(uint offset) {
    pio_sm_config c = pio_get_default_sm_config();
    sm_config_set_wrap(&c, offset + pio0_sm0_wrap_target, offset + pio0_sm0_wrap);
    sm_config_set_sideset(&c, 3, false, false);
    return c;
}

// see also (api):   https://raspberrypi.github.io/pico-sdk-doxygen/group__hardware__pio.html
// see also (pio.h): https://raspberrypi.github.io/pico-sdk-doxygen/rp2__common_2hardware__pio_2include_2hardware_2pio_8h_source.html
// see also (sm):    https://raspberrypi.github.io/pico-sdk-doxygen/group__sm__config.html
void pio0_sm0_config(
	PIO		pio,
	uint	sm,
	float	clkdiv
)
{
	int		i;
	uint	prog_addr;
	if (clkdiv < 1.0) {
		printf("asm_exec(): too small clkdiv\n");
		return;
	}
	// load program to PIO
	prog_addr			= pio_add_program(pio, &pio0_sm0_program);
	pio_sm_config	c	= pio0_sm0_program_get_default_config(prog_addr);	// addr
	sm_config_set_clkdiv(&c, clkdiv);	// pio_sm_config *c, float div
	// input
	if (-1 > 0) {
		for (i = 0; i < -1; i++) {
			pio_gpio_init(pio, -1 + i);	// PIO pio, uint pin
			pio_sm_set_consecutive_pindirs(pio, sm, -1 + i, 1, false);	// PIO pio, uint sm, uint pin_base, uint pin_count, bool is_out
		}
		sm_config_set_in_pins(&c, -1);	// pio_sm_config *c, uint in_base
	}
	// sideset
	if (3 > 0) {
		for (i = 0; i < 3; i++) {
			pio_gpio_init(pio, 0 + i);	// PIO pio, uint pin
			pio_sm_set_consecutive_pindirs(pio, sm, 0 + i, 1, true);	// PIO pio, uint sm, uint pin_base, uint pin_count, bool is_out
		}
		sm_config_set_sideset_pins(&c, 0);	// pio_sm_config *c, uint sideset_base
	}
	// output
	if (-1 > 0) {
		for (i = 0; i < -1; i++) {
			pio_gpio_init(pio, -1 + i);	// PIO pio, uint pin
			pio_sm_set_consecutive_pindirs(pio, sm, -1 + i, 1, true);	// PIO pio, uint sm, uint pin_base, uint pin_count, bool is_out
		}
		if (-1 <= 5)			sm_config_set_set_pins(&c, -1, -1);	// pio_sm_config *c, uint set_base, uint set_count
		else
			sm_config_set_set_pins(&c, -1, 5);	// pio_sm_config *c, uint set_base, uint set_count
		sm_config_set_out_pins(&c, -1, -1);	// pio_sm_config *c, uint out_base, uint out_count
	}
	// fifo, isr and osr
	sm_config_set_in_shift(&c, false, false, 32);		// pio_sm_config *c, bool shift_right, bool autopush, uint push_threshold
	sm_config_set_out_shift(&c, true, false, 32);		// pio_sm_config *c, bool shift_right, bool autopull, uint pull_threshold
	// "move status" instruction
	sm_config_set_mov_status(&c, STATUS_TX_LESSTHAN, 4);	// pio_sm_config *c, enum pio_mov_status_type status_sel, uint status_n
	pio_sm_clear_fifos(pio, sm);	// PIO pio, uint sm
	pio_sm_init(pio, sm, prog_addr, &c);	// PIO pio, uint sm, uint initial_pc, const pio_sm_config *config
}

#endif

